
//	MIT License
//
//	Copyright (c) 2017 Matej Artnak
//
//	Permission is hereby granted, free of charge, to any person obtaining a copy
//	of this software and associated documentation files (the "Software"), to deal
//	in the Software without restriction, including without limitation the rights
//	to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
//	copies of the Software, and to permit persons to whom the Software is
//	furnished to do so, subject to the following conditions:
//
//	The above copyright notice and this permission notice shall be included in all
//	copies or substantial portions of the Software.
//
//	THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
//	IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
//	FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
//	AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
//	LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
//	OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
//	SOFTWARE.
//
//
//
//-----------------------------------
//	ILI9341 Driver library for STM32
//-----------------------------------
//
//	While there are other libraries for ILI9341 they mostly require either interrupts, DMA or both for fast drawing
//	The intent of this library is to offer a simple yet still reasonably fast alternatives for those that
//	do not wish to use interrupts or DMA in their projects.
//
//	Library is written for STM32 HAL library and supports STM32CUBEMX. To use the library with Cube software
//	you need to tick the box that generates peripheral initialization code in their own respective .c and .h file
//
//
//-----------------------------------
//	Performance
//-----------------------------------
//	Settings:	
//	--SPI @ 50MHz 
//	--STM32F746ZG Nucleo board
//	--Redraw entire screen
//
//	++		Theoretical maximum FPS with 50Mhz SPI calculated to be 40.69 FPS
//	++		320*240 = 76800 pixels, each pixel contains 16bit colour information (2x8)
//	++		Theoretical Max FPS: 1/((320*240*16)/50000000)
//
//	With ART Accelerator, instruction prefetch, CPI ICACHE and CPU DCACHE enabled:
//
//	-FPS:									39.62
//	-SPI utilization:			97.37%
//	-MB/Second:						6.09
//
//	With ART Accelerator, instruction prefetch, CPI ICACHE and CPU DCACHE disabled:
//
//	-FPS:									35.45
//	-SPI utilization:			87.12%
//	-MB/Second:						5.44
//	
//	ART Accelerator, instruction prefetch, CPI ICACHE and CPU DCACHE settings found in MXCUBE under "System-> CORTEX M7 button"
//
//
//
//-----------------------------------
//	How to use this library
//-----------------------------------
//
//	-generate SPI peripheral and 3 GPIO_SPEED_FREQ_VERY_HIGH GPIO outputs
//	 		++Library reinitializes GPIOs and SPIs generated by gpio.c/.h and spi.c/.h using MX_X_Init(); calls
//			++reinitialization will not clash with previous initialization so generated initializations can be laft as they are
//	-If using MCUs other than STM32F7 you will have to change the #include "stm32f7xx_hal.h" in the ILI9341_STM32_Driver.h to your respective .h file
//	-define your HSPI_INSTANCE in ILI9341_STM32_Driver.h
//	-define your CS, DC and RST outputs in ILI9341_STM32_Driver.h
//	-check if ILI9341_SCREEN_HEIGHT and ILI9341_SCREEN_WIDTH match your LCD size
//			++Library was written and tested for 320x240 screen size. Other sizes might have issues**
//	-in your main program initialize LCD with ILI9341_Init();
//	-library is now ready to be used. Driver library has only basic functions, for more advanced functions see ILI9341_GFX library	
//
//-----------------------------------

/* Includes ------------------------------------------------------------------*/
#include "ILI9341_STM32_Driver.h"
#include "main.h"
#include "options.h"
#include "ILI9341_GFX.h"


extern SPI_HandleTypeDef hspi1;

extern uint16_t ILI9341_x;
extern uint16_t ILI9341_y;
extern TM_ILI931_Options_t ILI9341_Opts;

/* Global Variables ------------------------------------------------------------------*/
volatile uint16_t LCD_HEIGHT = ILI9481_HEIGHT;
volatile uint16_t LCD_WIDTH  = ILI9481_WIDTH;

// Generic commands used by TFT_eSPI.cpp
#define TFT_NOP     0x00
#define TFT_SWRST   0x01

#define TFT_SLPIN   0x10
#define TFT_SLPOUT  0x11

#define TFT_INVOFF  0x20
#define TFT_INVON   0x21

#define TFT_DISPOFF 0x28
#define TFT_DISPON  0x29

#define TFT_CASET   0x2A
#define TFT_PASET   0x2B
#define TFT_RAMWR   0x2C

#define TFT_RAMRD   0x2E

#define TFT_MADCTL  0x36

#define TFT_MAD_MY  0x80
#define TFT_MAD_MX  0x40
#define TFT_MAD_MV  0x20
#define TFT_MAD_ML  0x10
#define TFT_MAD_RGB 0x00
#define TFT_MAD_BGR 0x08
#define TFT_MAD_MH  0x04
#define TFT_MAD_SS  0x02
#define TFT_MAD_GS  0x01

#define TFT_IDXRD   0x00 // ILI9341 only, indexed control register read



/* Initialize SPI */
void ILI9341_SPI_Init(void)
{
//MX_SPI5_Init();																							//SPI INIT
//MX_GPIO_Init();																							//GPIO INIT
        HAL_GPIO_WritePin(LCD_CS_PORT, LCD_CS_PIN, GPIO_PIN_RESET);	//CS OFF
}






/*Send data (char) to LCD*/
void ILI9341_SPI_Send(unsigned char SPI_Data)
{
        HAL_SPI_Transmit(HSPI_INSTANCE, &SPI_Data, 1, 1);
}

void ILI9341_SPI16_Send(uint16_t SPI_Data)
{
        uint8_t tmp_tst[2] = {0};
        tmp_tst[0] = SPI_Data & 0xFF;
        tmp_tst[1] = (SPI_Data >> 8) & 0xFF;

        HAL_GPIO_WritePin(LCD_DC_PORT, LCD_DC_PIN, GPIO_PIN_SET);	
        HAL_GPIO_WritePin(LCD_CS_PORT, LCD_CS_PIN, GPIO_PIN_RESET);
        
        HAL_SPI_Transmit(HSPI_INSTANCE, tmp_tst, 2, 1);
        
        HAL_GPIO_WritePin(LCD_CS_PORT, LCD_CS_PIN, GPIO_PIN_SET);
}



/*
void ILI9341_SPI_Send_Mult(uint16_t SPI_Data, uint16_t size_dat)
{
        HAL_SPI_Transmit(HSPI_INSTANCE, &SPI_Data, size_dat, 1);
}
*/

         

void ILI9488_Write_Command_Data(uint8_t Cmd, uint8_t *pData, uint32_t Size)
{
        HAL_GPIO_WritePin(LCD_CS_PORT, LCD_CS_PIN, GPIO_PIN_RESET);
        HAL_GPIO_WritePin(LCD_DC_PORT, LCD_DC_PIN, GPIO_PIN_RESET);	
        HAL_SPI_Transmit(HSPI_INSTANCE, &Cmd, 1, 1);
        HAL_SPI_Transmit(HSPI_INSTANCE, pData, Size, 1);
        
        HAL_GPIO_WritePin(LCD_CS_PORT, LCD_CS_PIN, GPIO_PIN_SET);		
}

void ILI9488_Write_Data(uint8_t Data)
{
        //HAL_GPIO_WritePin(LCD_DC_PORT, LCD_DC_PIN, GPIO_PIN_SET);	
        //HAL_GPIO_WritePin(LCD_CS_PORT, LCD_CS_PIN, GPIO_PIN_RESET);
        ILI9341_SPI_Send(Data);	
        //HAL_GPIO_WritePin(LCD_CS_PORT, LCD_CS_PIN, GPIO_PIN_SET);
}

void ILI9488_Data_EN(void)
{
        HAL_GPIO_WritePin(LCD_DC_PORT, LCD_DC_PIN, GPIO_PIN_SET);	
        HAL_GPIO_WritePin(LCD_CS_PORT, LCD_CS_PIN, GPIO_PIN_RESET);
}

void ILI9488_Data_DIS(void)
{
        HAL_GPIO_WritePin(LCD_CS_PORT, LCD_CS_PIN, GPIO_PIN_SET);
}

/* Send command (char) to LCD */
void ILI9341_Write_Command(uint8_t Command)
{
        HAL_GPIO_WritePin(LCD_CS_PORT, LCD_CS_PIN, GPIO_PIN_RESET);
        HAL_GPIO_WritePin(LCD_DC_PORT, LCD_DC_PIN, GPIO_PIN_RESET);	
        ILI9341_SPI_Send(Command);
        HAL_GPIO_WritePin(LCD_CS_PORT, LCD_CS_PIN, GPIO_PIN_SET);		
}



/* Send Data (char) to LCD */
void ILI9341_Write_Data(uint8_t Data)
{
        HAL_GPIO_WritePin(LCD_DC_PORT, LCD_DC_PIN, GPIO_PIN_SET);	
        HAL_GPIO_WritePin(LCD_CS_PORT, LCD_CS_PIN, GPIO_PIN_RESET);
        ILI9341_SPI_Send(Data);	
        HAL_GPIO_WritePin(LCD_CS_PORT, LCD_CS_PIN, GPIO_PIN_SET);
}


/* Send command (char) to LCD */
void writecommand(uint8_t Command)
{
        HAL_GPIO_WritePin(LCD_CS_PORT, LCD_CS_PIN, GPIO_PIN_RESET);
        HAL_GPIO_WritePin(LCD_DC_PORT, LCD_DC_PIN, GPIO_PIN_RESET);	
        ILI9341_SPI_Send(Command);
        HAL_GPIO_WritePin(LCD_CS_PORT, LCD_CS_PIN, GPIO_PIN_SET);		
}

/* Send Data (char) to LCD */
void writedata(uint8_t Data)
{
        HAL_GPIO_WritePin(LCD_DC_PORT, LCD_DC_PIN, GPIO_PIN_SET);	
        HAL_GPIO_WritePin(LCD_CS_PORT, LCD_CS_PIN, GPIO_PIN_RESET);
        ILI9341_SPI_Send(Data);	
        HAL_GPIO_WritePin(LCD_CS_PORT, LCD_CS_PIN, GPIO_PIN_SET);
}




/* Set Address - Location block - to draw into */
void ILI9341_Set_Address(uint16_t X1, uint16_t Y1, uint16_t X2, uint16_t Y2)
{
        ILI9341_Write_Command(0x2A);
        ILI9341_Write_Data(X1>>8);
        ILI9341_Write_Data(X1);
        ILI9341_Write_Data(X2>>8);
        ILI9341_Write_Data(X2);

        ILI9341_Write_Command(0x2B);
        ILI9341_Write_Data(Y1>>8);
        ILI9341_Write_Data(Y1);
        ILI9341_Write_Data(Y2>>8);
        ILI9341_Write_Data(Y2);

        ILI9341_Write_Command(0x2C);
}

/*HARDWARE RESET*/
void ILI9341_Reset(void)
{
        HAL_GPIO_WritePin(LCD_RST_PORT, LCD_RST_PIN, GPIO_PIN_RESET);
        HAL_Delay(200);
        HAL_GPIO_WritePin(LCD_CS_PORT, LCD_CS_PIN, GPIO_PIN_RESET);
        HAL_Delay(200);
        HAL_GPIO_WritePin(LCD_RST_PORT, LCD_RST_PIN, GPIO_PIN_SET);	
}

/*Ser rotation of the screen - changes x0 and y0*/
void ILI9341_Set_Rotation(uint8_t Rotation) 
{
	
uint8_t screen_rotation = Rotation;

ILI9341_Write_Command(0x36);
HAL_Delay(1);
	
switch(screen_rotation) 
	{
		case SCREEN_VERTICAL_1:
			ILI9341_Write_Data(0x40|0x08);
			LCD_WIDTH = 320;
			LCD_HEIGHT = 480;
			break;
		case SCREEN_HORIZONTAL_1:
			ILI9341_Write_Data(0x20|0x08);
			LCD_WIDTH  = 480;
			LCD_HEIGHT = 320;
			break;
		case SCREEN_VERTICAL_2:
			ILI9341_Write_Data(0x80|0x08);
			LCD_WIDTH  = 320;
			LCD_HEIGHT = 480;
			break;
		case SCREEN_HORIZONTAL_2:
			ILI9341_Write_Data(0x40|0x80|0x20|0x08);
			LCD_WIDTH  = 480;
			LCD_HEIGHT = 320;
			break;
		default:
			//EXIT IF SCREEN ROTATION NOT VALID!
			break;
	}
        
        
        ILI9341_Opts.width = ILI9341_WIDTH;
	ILI9341_Opts.height = ILI9341_HEIGHT;
}

void ILI9481_Set_Rotation(uint8_t m)
{
 uint8_t rotation = 0;
 writecommand(TFT_MADCTL);
  rotation = m % 4;
  switch (rotation) {
   case 0: // Portrait
     writedata(TFT_MAD_BGR | TFT_MAD_SS);
   	LCD_WIDTH = ILI9481_WIDTH;
	LCD_HEIGHT = ILI9481_HEIGHT;
    //  _width  = TFT_WIDTH;
//      _height = TFT_HEIGHT;
     break;
   case 1: // Landscape (Portrait + 90)
     writedata(TFT_MAD_MV | TFT_MAD_BGR);
   	LCD_WIDTH = ILI9481_HEIGHT;
	LCD_HEIGHT = ILI9481_WIDTH;
      //_width  = TFT_HEIGHT;
      //_height = TFT_WIDTH;
     break;
   case 2: // Inverter portrait
     writedata(TFT_MAD_BGR | TFT_MAD_GS);
   	LCD_WIDTH = ILI9481_WIDTH;
	LCD_HEIGHT = ILI9481_HEIGHT;
      //_width  = TFT_WIDTH;
      //_height = TFT_HEIGHT;
     break;
   case 3: // Inverted landscape
     writedata(TFT_MAD_MV | TFT_MAD_BGR | TFT_MAD_SS | TFT_MAD_GS);
   	LCD_WIDTH = ILI9481_HEIGHT;
	LCD_HEIGHT = ILI9481_WIDTH;
      //_width  = TFT_HEIGHT;
      //_height = TFT_WIDTH;
     break;
  }
}
  

/*Enable LCD display*/
void ILI9341_Enable(void)
{
        HAL_GPIO_WritePin(LCD_RST_PORT, LCD_RST_PIN, GPIO_PIN_SET);
}

        /*Initialize LCD display*/
void ILI9341_Init(void)
{

        ILI9341_Enable();
        ILI9341_SPI_Init();
        ILI9341_Reset();

        //SOFTWARE RESET
        ILI9341_Write_Command(0x01);
        HAL_Delay(100);
                
        //POWER CONTROL A
        ILI9341_Write_Command(0xCB);
        ILI9341_Write_Data(0x39);
        ILI9341_Write_Data(0x2C);
        ILI9341_Write_Data(0x00);
        ILI9341_Write_Data(0x34);
        ILI9341_Write_Data(0x02);

        //POWER CONTROL B
        ILI9341_Write_Command(0xCF);
        ILI9341_Write_Data(0x00);
        ILI9341_Write_Data(0xC1);
        ILI9341_Write_Data(0x30);

        //DRIVER TIMING CONTROL A
        ILI9341_Write_Command(0xE8);
        ILI9341_Write_Data(0x85);
        ILI9341_Write_Data(0x00);
        ILI9341_Write_Data(0x78);

        //DRIVER TIMING CONTROL B
        ILI9341_Write_Command(0xEA);
        ILI9341_Write_Data(0x00);
        ILI9341_Write_Data(0x00);

        //POWER ON SEQUENCE CONTROL
        ILI9341_Write_Command(0xED);
        ILI9341_Write_Data(0x64);
        ILI9341_Write_Data(0x03);
        ILI9341_Write_Data(0x12);
        ILI9341_Write_Data(0x81);

        //PUMP RATIO CONTROL
        ILI9341_Write_Command(0xF7);
        ILI9341_Write_Data(0x20);

        //POWER CONTROL,VRH[5:0]
        ILI9341_Write_Command(0xC0);
        ILI9341_Write_Data(0x23);

        //POWER CONTROL,SAP[2:0];BT[3:0]
        ILI9341_Write_Command(0xC1);
        ILI9341_Write_Data(0x10);

        //VCM CONTROL
        ILI9341_Write_Command(0xC5);
        ILI9341_Write_Data(0x3E);
        ILI9341_Write_Data(0x28);

        //VCM CONTROL 2
        ILI9341_Write_Command(0xC7);
        ILI9341_Write_Data(0x86);

        //MEMORY ACCESS CONTROL
        ILI9341_Write_Command(0x36);
        ILI9341_Write_Data(0x48);

        //PIXEL FORMAT
        ILI9341_Write_Command(0x3A);
        ILI9341_Write_Data(0x55);

        //FRAME RATIO CONTROL, STANDARD RGB COLOR
        ILI9341_Write_Command(0xB1);
        ILI9341_Write_Data(0x00);
        ILI9341_Write_Data(0x18);

        //DISPLAY FUNCTION CONTROL
        ILI9341_Write_Command(0xB6);
        ILI9341_Write_Data(0x08);
        ILI9341_Write_Data(0x82);
        ILI9341_Write_Data(0x27);

        //3GAMMA FUNCTION DISABLE
        ILI9341_Write_Command(0xF2);
        ILI9341_Write_Data(0x00);

        //GAMMA CURVE SELECTED
        ILI9341_Write_Command(0x26);
        ILI9341_Write_Data(0x01);

        //POSITIVE GAMMA CORRECTION
        ILI9341_Write_Command(0xE0);
        ILI9341_Write_Data(0x0F);
        ILI9341_Write_Data(0x31);
        ILI9341_Write_Data(0x2B);
        ILI9341_Write_Data(0x0C);
        ILI9341_Write_Data(0x0E);
        ILI9341_Write_Data(0x08);
        ILI9341_Write_Data(0x4E);
        ILI9341_Write_Data(0xF1);
        ILI9341_Write_Data(0x37);
        ILI9341_Write_Data(0x07);
        ILI9341_Write_Data(0x10);
        ILI9341_Write_Data(0x03);
        ILI9341_Write_Data(0x0E);
        ILI9341_Write_Data(0x09);
        ILI9341_Write_Data(0x00);

        //NEGATIVE GAMMA CORRECTION
        ILI9341_Write_Command(0xE1);
        ILI9341_Write_Data(0x00);
        ILI9341_Write_Data(0x0E);
        ILI9341_Write_Data(0x14);
        ILI9341_Write_Data(0x03);
        ILI9341_Write_Data(0x11);
        ILI9341_Write_Data(0x07);
        ILI9341_Write_Data(0x31);
        ILI9341_Write_Data(0xC1);
        ILI9341_Write_Data(0x48);
        ILI9341_Write_Data(0x08);
        ILI9341_Write_Data(0x0F);
        ILI9341_Write_Data(0x0C);
        ILI9341_Write_Data(0x31);
        ILI9341_Write_Data(0x36);
        ILI9341_Write_Data(0x0F);

        //EXIT SLEEP
        ILI9341_Write_Command(0x11);
        HAL_Delay(120);

        //TURN ON DISPLAY
        ILI9341_Write_Command(0x29);

        //STARTING ROTATION
        ILI9341_Set_Rotation(SCREEN_VERTICAL_1);
        
        	/* Set default settings */
	ILI9341_Opts.width = ILI9341_WIDTH;
	ILI9341_Opts.height = ILI9341_HEIGHT;
}


void ILI9481_Init(void)
{
        
        writecommand(0xE0); // Positive Gamma Control
    writedata(0x00);
    writedata(0x03);
    writedata(0x09);
    writedata(0x08);
    writedata(0x16);
    writedata(0x0A);
    writedata(0x3F);
    writedata(0x78);
    writedata(0x4C);
    writedata(0x09);
    writedata(0x0A);
    writedata(0x08);
    writedata(0x16);
    writedata(0x1A);
    writedata(0x0F);

    writecommand(0XE1); // Negative Gamma Control
    writedata(0x00);
    writedata(0x16);
    writedata(0x19);
    writedata(0x03);
    writedata(0x0F);
    writedata(0x05);
    writedata(0x32);
    writedata(0x45);
    writedata(0x46);
    writedata(0x04);
    writedata(0x0E);
    writedata(0x0D);
    writedata(0x35);
    writedata(0x37);
    writedata(0x0F);

    writecommand(0XC0); // Power Control 1
    writedata(0x17);
    writedata(0x15);

    writecommand(0xC1); // Power Control 2
    writedata(0x41);

    writecommand(0xC5); // VCOM Control
    writedata(0x00);
    writedata(0x12);
    writedata(0x80);

    writecommand(TFT_MADCTL); // Memory Access Control
    writedata(0x48);          // MX, BGR

    writecommand(0x3A); // Pixel Interface Format
#if defined (TFT_PARALLEL_8_BIT) || defined (RPI_DISPLAY_TYPE)
    writedata(0x55);  // 16 bit colour for parallel
#else
    writedata(0x66);  // 18 bit colour for SPI
#endif

    writecommand(0xB0); // Interface Mode Control
    writedata(0x00);

    writecommand(0xB1); // Frame Rate Control
    writedata(0xA0);

    writecommand(0xB4); // Display Inversion Control
    writedata(0x02);

    writecommand(0xB6); // Display Function Control
    writedata(0x02);
    writedata(0x02);
    writedata(0x3B);

    writecommand(0xB7); // Entry Mode Set
    writedata(0xC6);

    writecommand(0xF7); // Adjust Control 3
    writedata(0xA9);
    writedata(0x51);
    writedata(0x2C);
    writedata(0x82);

    writecommand(TFT_SLPOUT);  //Exit Sleep
HAL_Delay(120);

    writecommand(TFT_DISPON);  //Display on
HAL_Delay(25);

ILI9341_Opts.width = ILI9481_WIDTH;
ILI9341_Opts.height = ILI9481_HEIGHT;
        


}


//INTERNAL FUNCTION OF LIBRARY, USAGE NOT RECOMENDED, USE Draw_Pixel INSTEAD
/*Sends single pixel colour information to LCD*/
void ILI9341_Draw_Colour(uint16_t Colour)
{
        //SENDS COLOUR
        unsigned char TempBuffer[2] = {Colour>>8, Colour};	
        HAL_GPIO_WritePin(LCD_DC_PORT, LCD_DC_PIN, GPIO_PIN_SET);	
        HAL_GPIO_WritePin(LCD_CS_PORT, LCD_CS_PIN, GPIO_PIN_RESET);
        HAL_SPI_Transmit(HSPI_INSTANCE, TempBuffer, 2, 1);	
        HAL_GPIO_WritePin(LCD_CS_PORT, LCD_CS_PIN, GPIO_PIN_SET);
}

//INTERNAL FUNCTION OF LIBRARY
/*Sends block colour information to LCD*/
void ILI9341_Draw_Colour_Burst(uint16_t Colour, uint32_t Size)
{
        //SENDS COLOUR
        uint32_t Buffer_Size = 0;
        if((Size*2) < BURST_MAX_SIZE)
        {
                Buffer_Size = Size;
        }
        else
        {
                Buffer_Size = BURST_MAX_SIZE;
        }
                
        HAL_GPIO_WritePin(LCD_DC_PORT, LCD_DC_PIN, GPIO_PIN_SET);	
        HAL_GPIO_WritePin(LCD_CS_PORT, LCD_CS_PIN, GPIO_PIN_RESET);

        unsigned char chifted = 	Colour>>8;;
        unsigned char burst_buffer[Buffer_Size];
        for(uint32_t j = 0; j < Buffer_Size; j+=2)
                {
                        burst_buffer[j] = 	chifted;
                        burst_buffer[j+1] = Colour;
                }

        uint32_t Sending_Size = Size*2;
        uint32_t Sending_in_Block = Sending_Size/Buffer_Size;
        uint32_t Remainder_from_block = Sending_Size%Buffer_Size;

        if(Sending_in_Block != 0)
        {
                for(uint32_t j = 0; j < (Sending_in_Block); j++)
                        {
                                HAL_SPI_Transmit(HSPI_INSTANCE, (unsigned char *)burst_buffer, Buffer_Size, 10);	
                               // HAL_SPI_Transmit_IT(HSPI_INSTANCE, (unsigned char *)burst_buffer, Buffer_Size);	
                        }
        }

        //REMAINDER!
       HAL_SPI_Transmit(HSPI_INSTANCE, (unsigned char *)burst_buffer, Remainder_from_block, 10);	
      //  HAL_SPI_Transmit_IT(HSPI_INSTANCE, (unsigned char *)burst_buffer, Remainder_from_block);	
                
        HAL_GPIO_WritePin(LCD_CS_PORT, LCD_CS_PIN, GPIO_PIN_SET);
}

//FILL THE ENTIRE SCREEN WITH SELECTED COLOUR (either #define-d ones or custom 16bit)
/*Sets address (entire screen) and Sends Height*Width ammount of colour information to LCD*/
void ILI9341_Fill_Screen(uint16_t Colour)
{
        ILI9341_Set_Address(0,0,LCD_WIDTH,LCD_HEIGHT);	
        ILI9341_Draw_Colour_Burst(Colour, LCD_WIDTH*LCD_HEIGHT);	
}

void ftek_Fill_Screen(uint32_t Colour)
{
        ILI9341_Set_Address(0,0,LCD_WIDTH,LCD_HEIGHT);	
        
        ILI9341_Draw_Colour_Burst(Colour, LCD_WIDTH*LCD_HEIGHT);	
}

//DRAW PIXEL AT XY POSITION WITH SELECTED COLOUR
//
//Location is dependant on screen orientation. x0 and y0 locations change with orientations.
//Using pixels to draw big simple structures is not recommended as it is really slow
//Try using either rectangles or lines if possible
//
void ILI9341_Draw_Pixel(uint16_t X,uint16_t Y,uint16_t Colour) 
{
        if((X >=LCD_WIDTH) || (Y >=LCD_HEIGHT)) return;	//OUT OF BOUNDS!
                
        //ADDRESS
        HAL_GPIO_WritePin(LCD_DC_PORT, LCD_DC_PIN, GPIO_PIN_RESET);	
        HAL_GPIO_WritePin(LCD_CS_PORT, LCD_CS_PIN, GPIO_PIN_RESET);
        ILI9341_SPI_Send(0x2A);
        HAL_GPIO_WritePin(LCD_DC_PORT, LCD_DC_PIN, GPIO_PIN_SET);	
        HAL_GPIO_WritePin(LCD_CS_PORT, LCD_CS_PIN, GPIO_PIN_SET);		

        //XDATA
        HAL_GPIO_WritePin(LCD_CS_PORT, LCD_CS_PIN, GPIO_PIN_RESET);	
        unsigned char Temp_Buffer[4] = {X>>8,X, (X+1)>>8, (X+1)};
        HAL_SPI_Transmit(HSPI_INSTANCE, Temp_Buffer, 4, 1);
        HAL_GPIO_WritePin(LCD_CS_PORT, LCD_CS_PIN, GPIO_PIN_SET);

        //ADDRESS
        HAL_GPIO_WritePin(LCD_DC_PORT, LCD_DC_PIN, GPIO_PIN_RESET);	
        HAL_GPIO_WritePin(LCD_CS_PORT, LCD_CS_PIN, GPIO_PIN_RESET);	
        ILI9341_SPI_Send(0x2B);
        HAL_GPIO_WritePin(LCD_DC_PORT, LCD_DC_PIN, GPIO_PIN_SET);			
        HAL_GPIO_WritePin(LCD_CS_PORT, LCD_CS_PIN, GPIO_PIN_SET);			

        //YDATA
        HAL_GPIO_WritePin(LCD_CS_PORT, LCD_CS_PIN, GPIO_PIN_RESET);
        unsigned char Temp_Buffer1[4] = {Y>>8,Y, (Y+1)>>8, (Y+1)};
        HAL_SPI_Transmit(HSPI_INSTANCE, Temp_Buffer1, 4, 1);
        HAL_GPIO_WritePin(LCD_CS_PORT, LCD_CS_PIN, GPIO_PIN_SET);

        //ADDRESS	
        HAL_GPIO_WritePin(LCD_DC_PORT, LCD_DC_PIN, GPIO_PIN_RESET);	
        HAL_GPIO_WritePin(LCD_CS_PORT, LCD_CS_PIN, GPIO_PIN_RESET);	
        ILI9341_SPI_Send(0x2C);
        HAL_GPIO_WritePin(LCD_DC_PORT, LCD_DC_PIN, GPIO_PIN_SET);			
        HAL_GPIO_WritePin(LCD_CS_PORT, LCD_CS_PIN, GPIO_PIN_SET);			

        //COLOUR	
        HAL_GPIO_WritePin(LCD_CS_PORT, LCD_CS_PIN, GPIO_PIN_RESET);
        unsigned char Temp_Buffer2[2] = {Colour>>8, Colour};
        HAL_SPI_Transmit(HSPI_INSTANCE, Temp_Buffer2, 2, 1);
        HAL_GPIO_WritePin(LCD_CS_PORT, LCD_CS_PIN, GPIO_PIN_SET);
	
}

//DRAW RECTANGLE OF SET SIZE AND HEIGTH AT X and Y POSITION WITH CUSTOM COLOUR
//
//Rectangle is hollow. X and Y positions mark the upper left corner of rectangle
//As with all other draw calls x0 and y0 locations dependant on screen orientation
//

void ILI9341_Draw_Rectangle(uint16_t X, uint16_t Y, uint16_t Width, uint16_t Height, uint16_t Colour)
{
        if((X >=LCD_WIDTH) || (Y >=LCD_HEIGHT)) return;
        if((X+Width-1)>=LCD_WIDTH)
                {
                        Width=LCD_WIDTH-X;
                }
        if((Y+Height-1)>=LCD_HEIGHT)
                {
                        Height=LCD_HEIGHT-Y;
                }
        ILI9341_Set_Address(X, Y, X+Width-1, Y+Height-1);
        ILI9341_Draw_Colour_Burst(Colour, Height*Width);
}

//DRAW LINE FROM X,Y LOCATION to X+Width,Y LOCATION
void ILI9341_Draw_Horizontal_Line(uint16_t X, uint16_t Y, uint16_t Width, uint16_t Colour)
{
        if((X >=LCD_WIDTH) || (Y >=LCD_HEIGHT)) return;
        if((X+Width-1)>=LCD_WIDTH)
                {
                        Width=LCD_WIDTH-X;
                }
        ILI9341_Set_Address(X, Y, X+Width-1, Y);
        ILI9341_Draw_Colour_Burst(Colour, Width);
}

//DRAW LINE FROM X,Y LOCATION to X,Y+Height LOCATION
void ILI9341_Draw_Vertical_Line(uint16_t X, uint16_t Y, uint16_t Height, uint16_t Colour)
{
        if((X >=LCD_WIDTH) || (Y >=LCD_HEIGHT)) return;
        if((Y+Height-1)>=LCD_HEIGHT)
                {
                        Height=LCD_HEIGHT-Y;
                }
        ILI9341_Set_Address(X, Y, X, Y+Height-1);
        ILI9341_Draw_Colour_Burst(Colour, Height);
}



//Scroll
void Scroll(uint16_t X, uint16_t Y, uint16_t Height, uint16_t Colour)
{
        //send cmd 33h scrolling
        //send first line fixed part
        //send first height of fixed part
        

}
